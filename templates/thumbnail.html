<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RafLocalizer - Thumbnail Editor</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
</head>

<body>
    <!-- Header -->
    <header class="header">
        <div class="logo">
            <a href="/"
                style="display: flex; align-items: center; gap: 0.75rem; text-decoration: none; color: inherit;">
                <div class="logo-icon">
                    <i class="fab fa-youtube"></i>
                </div>
                <span class="logo-text">Raf<span class="accent">Localizer</span></span>
            </a>
        </div>
        <div class="header-actions">
            <a href="/translate" class="btn btn-ghost">
                <i class="fas fa-arrow-left"></i> Back to Translation
            </a>
            <span class="phase-badge phase3-badge"><i class="fas fa-image"></i> PHASE 3: THUMBNAIL</span>
        </div>
    </header>

    <!-- Main Container -->
    <div class="thumbnail-container">
        <!-- Left Panel: Thumbnail List (from translation) -->
        <div class="thumb-sidebar" id="thumb-sidebar">
            <div class="sidebar-header">
                <h3><i class="fas fa-images"></i> Thumbnails</h3>
            </div>
            <div class="thumb-list" id="thumb-list">
                <!-- Thumbnail items will be injected here -->
            </div>

            <!-- Manual URL Input -->
            <div class="manual-url-section">
                <h4><i class="fas fa-link"></i> Or Enter URL</h4>
                <div class="url-input-group">
                    <input type="text" id="manual-url" placeholder="YouTube video or image URL...">
                    <button class="btn btn-primary btn-sm" id="load-url-btn">
                        <i class="fas fa-download"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Center: Canvas Editor -->
        <div class="canvas-area">
            <div class="canvas-wrapper" id="canvas-wrapper">
                <canvas id="thumbnail-canvas"></canvas>
                <div class="selection-box" id="selection-box" style="display: none;">
                    <div class="resize-handle handle-nw" data-handle="nw"></div>
                    <div class="resize-handle handle-ne" data-handle="ne"></div>
                    <div class="resize-handle handle-sw" data-handle="sw"></div>
                    <div class="resize-handle handle-se" data-handle="se"></div>
                    <div class="resize-handle handle-n" data-handle="n"></div>
                    <div class="resize-handle handle-s" data-handle="s"></div>
                    <div class="resize-handle handle-e" data-handle="e"></div>
                    <div class="resize-handle handle-w" data-handle="w"></div>
                </div>
                <!-- Inline Text Editor (CorelDRAW-style) -->
                <textarea id="inline-text-editor" style="display: none; position: absolute; background: transparent; border: 2px solid #00BFFF; 
                    color: inherit; font-weight: bold; text-align: center; resize: none; overflow: hidden;
                    outline: none; padding: 5px; box-sizing: border-box; z-index: 100;" spellcheck="false"></textarea>
                <div class="canvas-placeholder" id="canvas-placeholder">
                    <i class="fas fa-image"></i>
                    <p>Select a thumbnail or enter a URL</p>
                </div>
            </div>

            <!-- Canvas Controls / Toolbar -->
            <div class="canvas-controls">
                <div class="toolbar-group">
                    <span class="toolbar-label">Tools:</span>
                    <button class="btn btn-ghost tool-btn" id="select-tool-btn" title="Select/Move">
                        <i class="fas fa-mouse-pointer"></i>
                    </button>
                    <button class="btn btn-ghost tool-btn" id="rect-tool-btn" title="Rectangle Tool" disabled>
                        <i class="fas fa-square"></i>
                    </button>
                    <button class="btn btn-ghost tool-btn" id="text-tool-btn" title="Text Tool" disabled>
                        <i class="fas fa-font"></i>
                    </button>
                </div>
                <div class="toolbar-divider"></div>

                <button class="btn btn-ghost" id="show-rect-btn" disabled style="display: none;">
                    <i class="fas fa-border-style"></i> Show Rectangle
                </button>
                <button class="btn btn-ghost" id="reset-btn" disabled>
                    <i class="fas fa-undo"></i> Reset
                </button>
            </div>
        </div>

        <!-- Right Panel: Text Editor & Controls -->
        <div class="text-panel">
            <div class="panel-section">
                <h3><i class="fas fa-font"></i> Text Content</h3>
                <textarea id="text-input" placeholder="Enter text to overlay..." rows="4"></textarea>
                <button class="btn btn-primary btn-full" id="apply-text-btn" disabled>
                    <i class="fas fa-plus"></i> Add Text to Thumbnail
                </button>
            </div>

            <div class="panel-section">
                <h3><i class="fas fa-palette"></i> Style</h3>

                <div class="control-group">
                    <label>Text Color (Main)</label>
                    <div class="color-picker-row">
                        <input type="color" id="text-color" value="#FFFF00">
                        <span class="color-label">#FFFF00</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>
                        <input type="checkbox" id="use-first-line-color"> First Line Different Color
                    </label>
                    <div class="color-picker-row" style="margin-top: 0.5rem;">
                        <input type="color" id="first-line-color" value="#FF0000">
                        <span class="color-label">#FF0000</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>
                        <input type="checkbox" id="use-background"> Show Background
                    </label>
                    <div class="color-picker-row" style="margin-top: 0.5rem;" id="bg-color-row">
                        <input type="color" id="bg-color" value="#000000">
                        <span class="color-label">#000000</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Alignment</label>
                    <div class="alignment-btns">
                        <button class="align-btn" data-align="left"><i class="fas fa-align-left"></i></button>
                        <button class="align-btn active" data-align="center"><i
                                class="fas fa-align-center"></i></button>
                        <button class="align-btn" data-align="right"><i class="fas fa-align-right"></i></button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Font Size: <span id="font-size-value">48</span>px</label>
                    <input type="range" id="font-size" min="20" max="100" value="48">
                </div>

                <div class="control-group">
                    <label>
                        <input type="checkbox" id="auto-fit" checked> Auto-fit text to region
                    </label>
                </div>
            </div>

            <div class="panel-section">
                <h3><i class="fas fa-download"></i> Export</h3>
                <div class="export-btns">
                    <button class="btn btn-primary btn-full" id="download-btn" disabled>
                        <i class="fas fa-download"></i> Download PNG
                    </button>
                    <button class="btn btn-ghost btn-full" id="copy-btn" disabled>
                        <i class="far fa-copy"></i> Copy to Clipboard
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // State
        let thumbnails = [];
        let currentImage = null;
        let originalImage = null;
        let selectionMode = false;
        let selectedRegion = null;
        let textSettings = {
            color: '#FFFF00',
            firstLineColor: '#FF0000',
            useFirstLineColor: false,
            bgColor: '#000000',
            useBackground: false,
            highlightColor: '#FF0000', // Color for *highlighted* words
            align: 'center',
            fontSize: 48,
            autoFit: true
        };

        // Current tool: 'select', 'rect', 'text'
        let currentTool = 'select';
        // Store drawn elements as objects (non-destructive editing)
        let drawnElements = [];
        // Currently selected element index (-1 = none)
        let selectedElementIndex = -1;
        // Inline text editing mode
        let isEditingText = false;
        let editingElementIndex = -1;

        const canvas = document.getElementById('thumbnail-canvas');
        const ctx = canvas.getContext('2d');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const selectionBox = document.getElementById('selection-box');
        const placeholder = document.getElementById('canvas-placeholder');

        // Initialize - Load thumbnails from sessionStorage
        function init() {
            const storedData = sessionStorage.getItem('thumbnailData');
            if (storedData) {
                thumbnails = JSON.parse(storedData);
                renderThumbnailList();
            }

            setupEventListeners();
        }

        function renderThumbnailList() {
            const list = document.getElementById('thumb-list');
            list.innerHTML = '';

            if (thumbnails.length === 0) {
                list.innerHTML = '<p class="no-thumbs">No thumbnails from translation. Use manual URL input.</p>';
                return;
            }

            thumbnails.forEach((thumb, index) => {
                const item = document.createElement('div');
                item.className = 'thumb-item';
                item.innerHTML = `
                    <img src="${thumb.thumbnail_url}" alt="${thumb.title}">
                    <div class="thumb-item-info">
                        <p class="thumb-title">${thumb.title}</p>
                        <p class="thumb-text-preview">${thumb.production_title || 'No title'}</p>
                    </div>
                `;
                item.addEventListener('click', () => loadThumbnail(thumb));
                list.appendChild(item);
            });
        }

        function loadThumbnail(thumb) {
            loadImageFromUrl(thumb.thumbnail_url);
            // Clean up title: remove emojis at start and everything after |
            let cleanTitle = thumb.production_title || '';
            // Remove content after | symbol
            if (cleanTitle.includes('|')) {
                cleanTitle = cleanTitle.split('|')[0].trim();
            }
            // Remove leading emojis (common emoji ranges)
            cleanTitle = cleanTitle.replace(/^[\u{1F300}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\s]+/gu, '');
            document.getElementById('text-input').value = cleanTitle;
        }

        function loadImageFromUrl(url) {
            placeholder.style.display = 'flex';
            placeholder.innerHTML = '<i class="fas fa-spinner fa-spin"></i><p>Loading...</p>';

            const img = new Image();
            img.crossOrigin = 'anonymous';

            img.onload = () => {
                originalImage = img;
                currentImage = img;

                // Set canvas size to match image
                canvas.width = img.width;
                canvas.height = img.height;

                // Draw image
                ctx.drawImage(img, 0, 0);

                placeholder.style.display = 'none';
                enableControls();
            };

            img.onerror = () => {
                // Try fetching through backend proxy
                fetchThumbnailFromBackend(url);
            };

            img.src = url;
        }

        async function fetchThumbnailFromBackend(url) {
            try {
                const res = await fetch('/api/thumbnail/fetch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: url })
                });
                const data = await res.json();

                if (data.success) {
                    const img = new Image();
                    img.onload = () => {
                        originalImage = img;
                        currentImage = img;
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        placeholder.style.display = 'none';
                        enableControls();
                    };
                    img.src = 'data:image/jpeg;base64,' + data.image;
                } else {
                    showError(data.error || 'Failed to load image');
                }
            } catch (err) {
                showError('Failed to fetch thumbnail');
            }
        }

        function showError(msg) {
            placeholder.innerHTML = `<i class="fas fa-exclamation-circle"></i><p>${msg}</p>`;
        }

        function enableControls() {
            document.getElementById('reset-btn').disabled = false;
            document.getElementById('apply-text-btn').disabled = false;
            document.getElementById('download-btn').disabled = false;
            document.getElementById('copy-btn').disabled = false;
            // Enable tool buttons
            document.getElementById('rect-tool-btn').disabled = false;
            document.getElementById('text-tool-btn').disabled = false;
        }

        function setupEventListeners() {
            // Manual URL load
            document.getElementById('load-url-btn').addEventListener('click', () => {
                const url = document.getElementById('manual-url').value.trim();
                if (url) {
                    // Convert YouTube video URL to thumbnail URL if needed
                    const thumbUrl = convertToThumbnailUrl(url);
                    loadImageFromUrl(thumbUrl);
                }
            });

            // Reset - clear everything and redraw original image
            document.getElementById('reset-btn').addEventListener('click', () => {
                if (originalImage) {
                    drawnElements = [];
                    selectedElementIndex = -1;
                    ctx.drawImage(originalImage, 0, 0);
                    selectedRegion = null;
                    selectionBox.style.display = 'none';
                    document.getElementById('show-rect-btn').style.display = 'none';
                }
            });

            // Show/Hide Rectangle for adjustments
            document.getElementById('show-rect-btn').addEventListener('click', () => {
                if (selectionBox.style.display === 'none') {
                    updateSelectionBoxPosition();
                    document.getElementById('show-rect-btn').innerHTML = '<i class="fas fa-eye-slash"></i> Hide Rectangle';
                } else {
                    selectionBox.style.display = 'none';
                    document.getElementById('show-rect-btn').innerHTML = '<i class="fas fa-border-style"></i> Show Rectangle';
                }
            });

            // Apply text - add text as movable element
            document.getElementById('apply-text-btn').addEventListener('click', addTextElement);

            // Tool selection handlers
            function setActiveTool(tool) {
                currentTool = tool;
                // Update button states
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(tool + '-tool-btn').classList.add('active');
                // Update cursor
                canvasWrapper.classList.remove('text-mode', 'rect-mode');
                if (tool === 'text') canvasWrapper.classList.add('text-mode');
                if (tool === 'rect') canvasWrapper.classList.add('rect-mode');
                // Disable selection mode if changing tool
                selectionMode = false;
            }

            document.getElementById('select-tool-btn').addEventListener('click', () => setActiveTool('select'));
            document.getElementById('rect-tool-btn').addEventListener('click', () => setActiveTool('rect'));
            document.getElementById('text-tool-btn').addEventListener('click', () => setActiveTool('text'));

            // Initialize with select tool active
            setActiveTool('select');

            // Color pickers - update selected element if one is selected
            document.getElementById('text-color').addEventListener('input', (e) => {
                textSettings.color = e.target.value;
                e.target.nextElementSibling.textContent = e.target.value.toUpperCase();
                // Update selected textbox element
                if (selectedElementIndex >= 0 && drawnElements[selectedElementIndex].type === 'textbox') {
                    drawnElements[selectedElementIndex].textColor = e.target.value;
                    renderCanvas();
                }
            });

            document.getElementById('bg-color').addEventListener('input', (e) => {
                textSettings.bgColor = e.target.value;
                e.target.nextElementSibling.textContent = e.target.value.toUpperCase();
                // Update selected element background
                if (selectedElementIndex >= 0) {
                    const elem = drawnElements[selectedElementIndex];
                    if (elem.type === 'textbox') {
                        elem.bgColor = e.target.value;
                    } else if (elem.type === 'rect') {
                        elem.color = e.target.value;
                    }
                    renderCanvas();
                }
            });

            // First line color controls
            document.getElementById('use-first-line-color').addEventListener('change', (e) => {
                textSettings.useFirstLineColor = e.target.checked;
                updatePreview();
            });

            document.getElementById('first-line-color').addEventListener('input', (e) => {
                textSettings.firstLineColor = e.target.value;
                e.target.nextElementSibling.textContent = e.target.value.toUpperCase();
                // Update selected textbox element first line color
                if (selectedElementIndex >= 0 && drawnElements[selectedElementIndex].type === 'textbox') {
                    drawnElements[selectedElementIndex].firstLineColor = e.target.value;
                    renderCanvas();
                }
            });

            // Alignment buttons - with live preview
            document.querySelectorAll('.align-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.align-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    textSettings.align = btn.dataset.align;
                    updatePreview();
                });
            });

            // Font size slider - update selected element
            document.getElementById('font-size').addEventListener('input', (e) => {
                textSettings.fontSize = parseInt(e.target.value);
                document.getElementById('font-size-value').textContent = e.target.value;
                // Update selected textbox element
                if (selectedElementIndex >= 0 && drawnElements[selectedElementIndex].type === 'textbox') {
                    drawnElements[selectedElementIndex].fontSize = parseInt(e.target.value);
                    renderCanvas();
                }
            });

            // Show Background checkbox
            document.getElementById('use-background').addEventListener('change', (e) => {
                textSettings.useBackground = e.target.checked;
                document.getElementById('bg-color-row').style.opacity = e.target.checked ? '1' : '0.5';
                // Update selected textbox element
                if (selectedElementIndex >= 0 && drawnElements[selectedElementIndex].type === 'textbox') {
                    drawnElements[selectedElementIndex].useBackground = e.target.checked;
                    renderCanvas();
                }
            });

            // Auto-fit checkbox - with live preview
            document.getElementById('auto-fit').addEventListener('change', (e) => {
                textSettings.autoFit = e.target.checked;
                updatePreview();
            });

            // Text input - with live preview (debounced)
            let textInputTimeout;
            document.getElementById('text-input').addEventListener('input', () => {
                clearTimeout(textInputTimeout);
                textInputTimeout = setTimeout(updatePreview, 300);
            });

            // Canvas selection and tool interactions
            let startX, startY, isDrawing = false;
            let rectDrawStart = null;
            let elementDragStart = null;
            let isDraggingElement = false;
            let isResizingElement = false;
            let resizeHandleType = null; // 'nw', 'ne', 'sw', 'se'
            let resizeStart = null;

            // Inline text editor element
            const inlineEditor = document.getElementById('inline-text-editor');

            // Start inline editing on a textbox element
            function startInlineEdit(elemIndex) {
                if (elemIndex < 0 || !drawnElements[elemIndex]) return;

                const elem = drawnElements[elemIndex];
                if (elem.type !== 'textbox' && elem.type !== 'text') return;

                isEditingText = true;
                editingElementIndex = elemIndex;
                selectedElementIndex = elemIndex;

                // Get element position on screen relative to canvas wrapper
                const canvasRect = canvas.getBoundingClientRect();
                const wrapperRect = canvasWrapper.getBoundingClientRect();
                const scaleX = canvasRect.width / canvas.width;
                const scaleY = canvasRect.height / canvas.height;

                // Calculate the offset of canvas within the wrapper
                const canvasOffsetX = canvasRect.left - wrapperRect.left;
                const canvasOffsetY = canvasRect.top - wrapperRect.top;

                // Calculate position and size matching the textbox exactly
                let editorX, editorY, editorW, editorH, fontSize;

                if (elem.type === 'textbox') {
                    // Match the exact position and size of the rendered textbox
                    editorX = canvasOffsetX + (elem.x * scaleX);
                    editorY = canvasOffsetY + (elem.y * scaleY);
                    editorW = (elem._width || 300) * scaleX;
                    editorH = (elem._height || 100) * scaleY;
                    fontSize = elem.fontSize * scaleY;
                } else {
                    ctx.font = `bold ${elem.fontSize}px Arial`;
                    const metrics = ctx.measureText(elem.text);
                    editorX = canvasOffsetX + (elem.x * scaleX);
                    editorY = canvasOffsetY + (elem.y * scaleY);
                    editorW = metrics.width * scaleX + 40;
                    editorH = elem.fontSize * scaleY * 1.5;
                    fontSize = elem.fontSize * scaleY;
                }

                // Position and style the editor to match textbox exactly
                inlineEditor.style.left = editorX + 'px';
                inlineEditor.style.top = editorY + 'px';
                inlineEditor.style.width = Math.max(editorW, 200) + 'px';
                inlineEditor.style.height = Math.max(editorH, 60) + 'px';
                inlineEditor.style.fontSize = fontSize + 'px';
                inlineEditor.style.lineHeight = (fontSize * 1.1) + 'px';
                inlineEditor.style.color = elem.textColor || elem.color || textSettings.color;
                inlineEditor.style.backgroundColor = elem.bgColor || textSettings.bgColor;
                // Match the padding used in renderCanvas for textbox
                inlineEditor.style.padding = (10 * scaleY) + 'px ' + (20 * scaleX) + 'px';
                inlineEditor.style.display = 'block';

                // Set the text - preserve newlines
                inlineEditor.value = elem.text;
                inlineEditor.focus();
                inlineEditor.select();

                // Hide the element while editing (redraw without it)
                renderCanvas();
            }

            // Finish inline editing and save
            function finishInlineEdit() {
                if (!isEditingText || editingElementIndex < 0) return;

                const elem = drawnElements[editingElementIndex];
                const newText = inlineEditor.value.trim().toUpperCase();

                if (newText !== '') {
                    elem.text = newText;
                }

                // Hide editor
                inlineEditor.style.display = 'none';
                inlineEditor.value = '';

                isEditingText = false;
                editingElementIndex = -1;

                renderCanvas();
            }

            // Cancel inline editing
            function cancelInlineEdit() {
                inlineEditor.style.display = 'none';
                inlineEditor.value = '';
                isEditingText = false;
                editingElementIndex = -1;
                renderCanvas();
            }

            // Inline editor event handlers
            inlineEditor.addEventListener('blur', () => {
                // Small delay to allow for intentional cancellation
                setTimeout(() => {
                    if (isEditingText) {
                        finishInlineEdit();
                    }
                }, 100);
            });

            inlineEditor.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    cancelInlineEdit();
                    e.preventDefault();
                }
                // Enter creates new line (default behavior for textarea)
                // Ctrl+Enter to finish editing
                if (e.key === 'Enter' && e.ctrlKey) {
                    finishInlineEdit();
                    e.preventDefault();
                }
            });

            // Auto-resize editor as user types
            inlineEditor.addEventListener('input', () => {
                // Adjust height to fit content
                inlineEditor.style.height = 'auto';
                inlineEditor.style.height = Math.max(50, inlineEditor.scrollHeight) + 'px';
            });

            // Delete key to remove selected element
            document.addEventListener('keydown', (e) => {
                // Don't handle if editing text or if input/textarea is focused
                if (isEditingText) return;
                if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return;

                if ((e.key === 'Delete' || e.key === 'Backspace') && selectedElementIndex >= 0) {
                    drawnElements.splice(selectedElementIndex, 1);
                    selectedElementIndex = -1;
                    renderCanvas();
                    e.preventDefault();
                }
            });

            // Double-click to enter inline edit mode
            canvasWrapper.addEventListener('dblclick', (e) => {
                if (!currentImage) return;
                if (isEditingText) return; // Already editing

                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const clickX = (e.clientX - rect.left) * scaleX;
                const clickY = (e.clientY - rect.top) * scaleY;

                const hitIndex = hitTestElement(clickX, clickY);
                if (hitIndex >= 0 && (drawnElements[hitIndex].type === 'text' || drawnElements[hitIndex].type === 'textbox')) {
                    startInlineEdit(hitIndex);
                    e.stopPropagation();
                }
            });

            canvasWrapper.addEventListener('mousedown', (e) => {
                if (!currentImage) return;

                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const clickX = (e.clientX - rect.left) * scaleX;
                const clickY = (e.clientY - rect.top) * scaleY;

                if (currentTool === 'select') {
                    // First check if clicking on a resize handle of selected element
                    if (selectedElementIndex >= 0) {
                        const handle = hitTestResizeHandle(clickX, clickY);
                        if (handle) {
                            isResizingElement = true;
                            resizeHandleType = handle;
                            const elem = drawnElements[selectedElementIndex];
                            // Get width/height - for textbox use _width/_height
                            let elemW = elem.width || elem._width || 0;
                            let elemH = elem.height || elem._height || elem.fontSize || 0;
                            resizeStart = {
                                x: clickX, y: clickY,
                                elemX: elem.x, elemY: elem.y,
                                elemW: elemW, elemH: elemH,
                                fontSize: elem.fontSize // Save for proportional scaling
                            };
                            return;
                        }
                    }

                    // Select tool - check if clicking on an element
                    const hitIndex = hitTestElement(clickX, clickY);
                    if (hitIndex >= 0) {
                        selectedElementIndex = hitIndex;
                        const elem = drawnElements[hitIndex];
                        elementDragStart = { x: clickX, y: clickY, elemX: elem.x, elemY: elem.y };
                        isDraggingElement = true;
                        renderCanvas();
                    } else {
                        // Deselect if clicking empty area
                        selectedElementIndex = -1;
                        renderCanvas();
                    }
                } else if (currentTool === 'rect') {
                    // Start drawing rectangle
                    rectDrawStart = { x: clickX, y: clickY };
                    isDrawing = true;
                } else if (currentTool === 'text') {
                    // Add text at click position
                    const text = prompt('Enter text:');
                    if (text) {
                        // Create textbox element with all current settings (same as Add Text button)
                        drawnElements.push({
                            type: 'textbox',
                            text: text.toUpperCase(),
                            x: clickX,
                            y: clickY,
                            fontSize: textSettings.fontSize,
                            textColor: textSettings.color,
                            bgColor: textSettings.bgColor,
                            useBackground: textSettings.useBackground,
                            firstLineColor: textSettings.firstLineColor,
                            useFirstLineColor: textSettings.useFirstLineColor,
                            highlightColor: textSettings.firstLineColor, // Use first line color for highlights
                            maxWidth: 600,
                            _width: 0,
                            _height: 0
                        });
                        selectedElementIndex = drawnElements.length - 1;
                        renderCanvas();
                    }
                } else if (selectionMode) {
                    // Region selection mode
                    startX = clickX;
                    startY = clickY;
                    isDrawing = true;
                    selectionBox.style.display = 'block';
                }
            });

            canvasWrapper.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const currentX = (e.clientX - rect.left) * scaleX;
                const currentY = (e.clientY - rect.top) * scaleY;

                // Resizing an element
                if (isResizingElement && selectedElementIndex >= 0 && resizeStart) {
                    const elem = drawnElements[selectedElementIndex];
                    const deltaX = currentX - resizeStart.x;
                    const deltaY = currentY - resizeStart.y;

                    if (elem.type === 'rect' || elem.type === 'textbox') {
                        // Handle all 8 resize handles
                        const minSize = 20;

                        // Corner handles
                        if (resizeHandleType === 'se') {
                            elem.width = Math.max(minSize, resizeStart.elemW + deltaX);
                            elem.height = Math.max(minSize, resizeStart.elemH + deltaY);
                        } else if (resizeHandleType === 'sw') {
                            elem.x = resizeStart.elemX + deltaX;
                            elem.width = Math.max(minSize, resizeStart.elemW - deltaX);
                            elem.height = Math.max(minSize, resizeStart.elemH + deltaY);
                        } else if (resizeHandleType === 'ne') {
                            elem.y = resizeStart.elemY + deltaY;
                            elem.width = Math.max(minSize, resizeStart.elemW + deltaX);
                            elem.height = Math.max(minSize, resizeStart.elemH - deltaY);
                        } else if (resizeHandleType === 'nw') {
                            elem.x = resizeStart.elemX + deltaX;
                            elem.y = resizeStart.elemY + deltaY;
                            elem.width = Math.max(minSize, resizeStart.elemW - deltaX);
                            elem.height = Math.max(minSize, resizeStart.elemH - deltaY);
                        }
                        // Side handles (horizontal/vertical only)
                        else if (resizeHandleType === 'n') {
                            elem.y = resizeStart.elemY + deltaY;
                            elem.height = Math.max(minSize, resizeStart.elemH - deltaY);
                        } else if (resizeHandleType === 's') {
                            elem.height = Math.max(minSize, resizeStart.elemH + deltaY);
                        } else if (resizeHandleType === 'e') {
                            elem.width = Math.max(minSize, resizeStart.elemW + deltaX);
                        } else if (resizeHandleType === 'w') {
                            elem.x = resizeStart.elemX + deltaX;
                            elem.width = Math.max(minSize, resizeStart.elemW - deltaX);
                        }

                        // For textbox, update properties and scale font with vertical resize
                        if (elem.type === 'textbox') {
                            elem.maxWidth = elem.width - 40; // Account for padding
                            elem._width = elem.width;
                            elem._height = elem.height;

                            // Scale font size proportionally on vertical resize
                            if (['n', 's', 'nw', 'ne', 'sw', 'se'].includes(resizeHandleType)) {
                                const heightRatio = elem.height / resizeStart.elemH;
                                const baseFontSize = resizeStart.fontSize || elem.fontSize;
                                elem.fontSize = Math.max(12, Math.min(200, Math.round(baseFontSize * heightRatio)));
                            }
                        }
                    } else if (elem.type === 'text') {
                        // For text, resize means change font size
                        const newSize = resizeStart.elemH + deltaY;
                        elem.fontSize = Math.max(12, Math.min(200, newSize));
                    }
                    renderCanvas();
                    return;
                }

                // Dragging an element
                if (isDraggingElement && selectedElementIndex >= 0 && elementDragStart) {
                    const deltaX = currentX - elementDragStart.x;
                    const deltaY = currentY - elementDragStart.y;
                    drawnElements[selectedElementIndex].x = elementDragStart.elemX + deltaX;
                    drawnElements[selectedElementIndex].y = elementDragStart.elemY + deltaY;
                    renderCanvas();
                    return;
                }

                if (!isDrawing) return;

                const width = currentX - startX;
                const height = currentY - startY;

                // Update selection box visual
                const displayScaleX = rect.width / canvas.width;
                const displayScaleY = rect.height / canvas.height;

                selectionBox.style.left = (Math.min(startX, currentX) * displayScaleX) + 'px';
                selectionBox.style.top = (Math.min(startY, currentY) * displayScaleY) + 'px';
                selectionBox.style.width = (Math.abs(width) * displayScaleX) + 'px';
                selectionBox.style.height = (Math.abs(height) * displayScaleY) + 'px';
            });

            canvasWrapper.addEventListener('mouseup', (e) => {
                // Stop resizing element
                if (isResizingElement) {
                    isResizingElement = false;
                    resizeHandleType = null;
                    resizeStart = null;
                    return;
                }

                // Stop dragging element
                if (isDraggingElement) {
                    isDraggingElement = false;
                    elementDragStart = null;
                    return;
                }

                if (!isDrawing) return;
                isDrawing = false;

                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const endX = (e.clientX - rect.left) * scaleX;
                const endY = (e.clientY - rect.top) * scaleY;

                if (currentTool === 'rect' && rectDrawStart) {
                    // Add rectangle to elements array (non-destructive)
                    const rectX = Math.min(rectDrawStart.x, endX);
                    const rectY = Math.min(rectDrawStart.y, endY);
                    const rectW = Math.abs(endX - rectDrawStart.x);
                    const rectH = Math.abs(endY - rectDrawStart.y);

                    if (rectW > 5 && rectH > 5) {
                        drawnElements.push({
                            type: 'rect',
                            x: rectX,
                            y: rectY,
                            width: rectW,
                            height: rectH,
                            color: textSettings.bgColor
                        });
                        selectedElementIndex = drawnElements.length - 1;
                        renderCanvas();
                    }
                    rectDrawStart = null;
                } else if (selectionMode) {
                    // Selection mode
                    selectionMode = false;
                    canvasWrapper.style.cursor = 'default';

                    selectedRegion = {
                        x: Math.min(startX, endX),
                        y: Math.min(startY, endY),
                        width: Math.abs(endX - startX),
                        height: Math.abs(endY - startY)
                    };

                    updateSelectionBoxPosition();
                }
            });

            // Selection box drag and resize
            let isDragging = false;
            let isResizing = false;
            let resizeHandle = null;
            let dragStartX, dragStartY;
            let originalRegion = null;

            selectionBox.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('resize-handle')) {
                    isResizing = true;
                    resizeHandle = e.target.dataset.handle;
                } else {
                    isDragging = true;
                }

                const rect = canvas.getBoundingClientRect();
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                originalRegion = { ...selectedRegion };
                e.stopPropagation();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging && !isResizing) return;
                if (!selectedRegion) return;

                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const deltaX = (e.clientX - dragStartX) * scaleX;
                const deltaY = (e.clientY - dragStartY) * scaleY;

                if (isDragging) {
                    selectedRegion.x = originalRegion.x + deltaX;
                    selectedRegion.y = originalRegion.y + deltaY;
                } else if (isResizing) {
                    switch (resizeHandle) {
                        case 'se':
                            selectedRegion.width = originalRegion.width + deltaX;
                            selectedRegion.height = originalRegion.height + deltaY;
                            break;
                        case 'sw':
                            selectedRegion.x = originalRegion.x + deltaX;
                            selectedRegion.width = originalRegion.width - deltaX;
                            selectedRegion.height = originalRegion.height + deltaY;
                            break;
                        case 'ne':
                            selectedRegion.y = originalRegion.y + deltaY;
                            selectedRegion.width = originalRegion.width + deltaX;
                            selectedRegion.height = originalRegion.height - deltaY;
                            break;
                        case 'nw':
                            selectedRegion.x = originalRegion.x + deltaX;
                            selectedRegion.y = originalRegion.y + deltaY;
                            selectedRegion.width = originalRegion.width - deltaX;
                            selectedRegion.height = originalRegion.height - deltaY;
                            break;
                        case 'n':
                            selectedRegion.y = originalRegion.y + deltaY;
                            selectedRegion.height = originalRegion.height - deltaY;
                            break;
                        case 's':
                            selectedRegion.height = originalRegion.height + deltaY;
                            break;
                        case 'e':
                            selectedRegion.width = originalRegion.width + deltaX;
                            break;
                        case 'w':
                            selectedRegion.x = originalRegion.x + deltaX;
                            selectedRegion.width = originalRegion.width - deltaX;
                            break;
                    }
                }

                // Ensure minimum size
                selectedRegion.width = Math.max(50, selectedRegion.width);
                selectedRegion.height = Math.max(50, selectedRegion.height);

                updateSelectionBoxPosition();

                // Live update text when dragging/resizing
                updatePreview();
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
                isResizing = false;
                resizeHandle = null;
            });

            // Download button
            document.getElementById('download-btn').addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = 'thumbnail.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            });

            // Copy button
            document.getElementById('copy-btn').addEventListener('click', async () => {
                try {
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                    await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);

                    const btn = document.getElementById('copy-btn');
                    btn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                    setTimeout(() => {
                        btn.innerHTML = '<i class="far fa-copy"></i> Copy to Clipboard';
                    }, 2000);
                } catch (err) {
                    alert('Failed to copy to clipboard');
                }
            });
        }

        function updateSelectionBoxPosition() {
            if (!selectedRegion) return;

            const rect = canvas.getBoundingClientRect();
            const displayScaleX = rect.width / canvas.width;
            const displayScaleY = rect.height / canvas.height;

            selectionBox.style.display = 'block';
            selectionBox.style.left = (selectedRegion.x * displayScaleX) + 'px';
            selectionBox.style.top = (selectedRegion.y * displayScaleY) + 'px';
            selectionBox.style.width = (selectedRegion.width * displayScaleX) + 'px';
            selectionBox.style.height = (selectedRegion.height * displayScaleY) + 'px';
        }

        // Render canvas with all elements (non-destructive)
        function renderCanvas() {
            if (!originalImage) return;

            // Draw original image
            ctx.drawImage(originalImage, 0, 0);

            // Draw all elements
            drawnElements.forEach((elem, idx) => {
                // Skip the element being edited - inline editor replaces it visually
                if (isEditingText && idx === editingElementIndex) {
                    return;
                }

                if (elem.type === 'rect') {
                    ctx.fillStyle = elem.color;
                    ctx.fillRect(elem.x, elem.y, elem.width, elem.height);
                } else if (elem.type === 'text') {
                    ctx.fillStyle = elem.color;
                    ctx.font = `bold ${elem.fontSize}px Arial`;
                    ctx.textBaseline = 'top';
                    ctx.fillText(elem.text, elem.x, elem.y);
                } else if (elem.type === 'textbox') {
                    // Padding for text inside the box
                    const paddingX = 20;
                    const paddingY = 10;

                    // Calculate text dimensions first
                    ctx.font = `bold ${elem.fontSize}px Arial`;
                    const lines = wrapTextForElement(elem.text, elem.maxWidth || 600, elem.fontSize);
                    const lineHeight = elem.fontSize * 1.1;
                    const totalTextHeight = lines.length * lineHeight;

                    let maxLineWidth = 0;
                    lines.forEach(line => {
                        const metrics = ctx.measureText(line);
                        if (metrics.width > maxLineWidth) maxLineWidth = metrics.width;
                    });

                    // Calculate minimum size needed for text
                    const textNeedsWidth = maxLineWidth + paddingX * 2;
                    const textNeedsHeight = totalTextHeight + paddingY * 2;

                    // Background must be at least as big as the text needs
                    const rectWidth = Math.max(elem.width || 0, textNeedsWidth);
                    const rectHeight = Math.max(elem.height || 0, textNeedsHeight);

                    // Store dimensions for hit testing (don't modify elem.width/height during render)
                    elem._width = rectWidth;
                    elem._height = rectHeight;

                    // Draw background rectangle only if enabled
                    if (elem.useBackground !== false) {
                        ctx.fillStyle = elem.bgColor || '#000000';
                        ctx.fillRect(elem.x, elem.y, rectWidth, rectHeight);
                    }

                    // Save context state before changing textAlign
                    ctx.save();

                    // Draw text lines with word-level coloring support
                    // Words wrapped in *asterisks* are highlighted
                    ctx.textBaseline = 'top';
                    const startY = elem.y + paddingY;
                    const highlightColor = elem.highlightColor || elem.firstLineColor || '#FF0000';
                    const normalColor = elem.textColor || '#FFFF00';

                    lines.forEach((line, i) => {
                        // Parse line for *highlighted* words
                        const parts = line.split(/(\*[^*]+\*)/g);

                        // Calculate total line width for centering
                        let totalWidth = 0;
                        parts.forEach(part => {
                            const cleanPart = part.replace(/\*/g, '');
                            totalWidth += ctx.measureText(cleanPart).width;
                        });

                        // Start drawing from left, centered
                        let currentX = elem.x + (rectWidth - totalWidth) / 2;
                        const lineY = startY + i * lineHeight;

                        ctx.textAlign = 'left';
                        parts.forEach(part => {
                            const isHighlighted = part.startsWith('*') && part.endsWith('*');
                            const cleanPart = part.replace(/\*/g, '');

                            if (cleanPart) {
                                // Use first line color for first line if enabled
                                if (i === 0 && elem.useFirstLineColor && !isHighlighted) {
                                    ctx.fillStyle = elem.firstLineColor || '#FF0000';
                                } else if (isHighlighted) {
                                    ctx.fillStyle = highlightColor;
                                } else {
                                    ctx.fillStyle = normalColor;
                                }
                                ctx.fillText(cleanPart, currentX, lineY);
                                currentX += ctx.measureText(cleanPart).width;
                            }
                        });
                    });

                    // Restore context state
                    ctx.restore();
                }

                // Draw selection handles if this element is selected (and not being edited)
                if (idx === selectedElementIndex && !isEditingText) {
                    drawSelectionHandles(elem);
                }
            });
        }

        // Helper function to wrap text for textbox element
        // Supports explicit line breaks from Enter key
        function wrapTextForElement(text, maxWidth, fontSize) {
            ctx.font = `bold ${fontSize}px Arial`;
            const lines = [];

            // First split by explicit line breaks (Enter key)
            const paragraphs = text.split('\n');

            paragraphs.forEach(paragraph => {
                if (paragraph.trim() === '') {
                    lines.push(''); // Keep empty lines for spacing
                    return;
                }

                const words = paragraph.split(' ');
                let currentLine = '';

                words.forEach(word => {
                    const testLine = currentLine ? currentLine + ' ' + word : word;
                    const metrics = ctx.measureText(testLine);

                    if (metrics.width > maxWidth && currentLine) {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = testLine;
                    }
                });

                if (currentLine) {
                    lines.push(currentLine);
                }
            });

            return lines.length > 0 ? lines : [text];
        }

        // Draw selection handles around an element
        function drawSelectionHandles(elem) {
            let x, y, w, h;
            if (elem.type === 'rect') {
                x = elem.x; y = elem.y; w = elem.width; h = elem.height;
            } else if (elem.type === 'text') {
                ctx.font = `bold ${elem.fontSize}px Arial`;
                const metrics = ctx.measureText(elem.text);
                x = elem.x; y = elem.y;
                w = metrics.width; h = elem.fontSize;
            } else if (elem.type === 'textbox') {
                x = elem.x; y = elem.y;
                w = elem._width || 100; h = elem._height || 50;
            }

            // Draw dashed border
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.strokeRect(x, y, w, h);
            ctx.setLineDash([]);

            // Draw 8 handles (CorelDRAW style: white fill, black border)
            const handleSize = 7;

            // All 8 handle positions
            const handles = [
                [x, y],                 // nw
                [x + w / 2, y],           // n
                [x + w, y],             // ne
                [x + w, y + h / 2],       // e
                [x + w, y + h],         // se
                [x + w / 2, y + h],       // s
                [x, y + h],             // sw
                [x, y + h / 2]            // w
            ];

            // Draw each handle as white square with black border
            handles.forEach(([hx, hy]) => {
                ctx.fillStyle = '#FFFFFF';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1;
                ctx.fillRect(hx - handleSize / 2, hy - handleSize / 2, handleSize, handleSize);
                ctx.strokeRect(hx - handleSize / 2, hy - handleSize / 2, handleSize, handleSize);
            });

            // Center cross marker
            const cx = x + w / 2;
            const cy = y + h / 2;
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(cx - 5, cy);
            ctx.lineTo(cx + 5, cy);
            ctx.moveTo(cx, cy - 5);
            ctx.lineTo(cx, cy + 5);
            ctx.stroke();
        }

        // Hit test - find which element is at the given canvas coordinates
        function hitTestElement(clickX, clickY) {
            // Check in reverse order (top elements first)
            for (let i = drawnElements.length - 1; i >= 0; i--) {
                const elem = drawnElements[i];
                let x, y, w, h;
                if (elem.type === 'rect') {
                    x = elem.x; y = elem.y; w = elem.width; h = elem.height;
                } else if (elem.type === 'text') {
                    ctx.font = `bold ${elem.fontSize}px Arial`;
                    const metrics = ctx.measureText(elem.text);
                    x = elem.x; y = elem.y;
                    w = metrics.width; h = elem.fontSize;
                } else if (elem.type === 'textbox') {
                    x = elem.x; y = elem.y;
                    w = elem._width || 100; h = elem._height || 50;
                }
                if (clickX >= x && clickX <= x + w && clickY >= y && clickY <= y + h) {
                    return i;
                }
            }
            return -1;
        }

        // Hit test for resize handles of selected element (8 handles)
        function hitTestResizeHandle(clickX, clickY) {
            if (selectedElementIndex < 0) return null;

            const elem = drawnElements[selectedElementIndex];
            let x, y, w, h;
            if (elem.type === 'rect') {
                x = elem.x; y = elem.y; w = elem.width; h = elem.height;
            } else if (elem.type === 'text') {
                ctx.font = `bold ${elem.fontSize}px Arial`;
                const metrics = ctx.measureText(elem.text);
                x = elem.x; y = elem.y;
                w = metrics.width; h = elem.fontSize;
            } else if (elem.type === 'textbox') {
                x = elem.x; y = elem.y;
                w = elem._width || 100; h = elem._height || 50;
            }

            const handleSize = 12; // Larger for easier clicking

            // All 8 handles
            const handles = {
                'nw': [x, y],
                'n': [x + w / 2, y],
                'ne': [x + w, y],
                'e': [x + w, y + h / 2],
                'se': [x + w, y + h],
                's': [x + w / 2, y + h],
                'sw': [x, y + h],
                'w': [x, y + h / 2]
            };

            for (const [name, [hx, hy]] of Object.entries(handles)) {
                if (clickX >= hx - handleSize / 2 && clickX <= hx + handleSize / 2 &&
                    clickY >= hy - handleSize / 2 && clickY <= hy + handleSize / 2) {
                    return name;
                }
            }
            return null;
        }

        function convertToThumbnailUrl(url) {
            // Convert YouTube video URL to thumbnail URL
            const videoIdMatch = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\s]+)/);
            if (videoIdMatch) {
                return `https://img.youtube.com/vi/${videoIdMatch[1]}/maxresdefault.jpg`;
            }
            return url; // Return as-is if not a YouTube URL
        }

        // Add text element - creates a movable textbox with background
        function addTextElement() {
            if (!currentImage) {
                alert('Please load a thumbnail first');
                return;
            }

            const text = document.getElementById('text-input').value.trim().toUpperCase();
            if (!text) {
                alert('Please enter text first');
                return;
            }

            // Create textbox element at center of canvas
            const centerX = canvas.width / 2 - 150;
            const centerY = canvas.height / 2 - 50;

            const textboxElement = {
                type: 'textbox',
                text: text,
                x: centerX,
                y: centerY,
                fontSize: textSettings.fontSize,
                textColor: textSettings.color,
                bgColor: textSettings.bgColor,
                useBackground: textSettings.useBackground,
                firstLineColor: textSettings.firstLineColor,
                useFirstLineColor: textSettings.useFirstLineColor,
                maxWidth: 600, // default max width for text wrapping
                _width: 0,
                _height: 0
            };

            drawnElements.push(textboxElement);
            selectedElementIndex = drawnElements.length - 1;

            // Switch to select tool so user can move the element
            currentTool = 'select';
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('select-tool-btn').classList.add('active');

            renderCanvas();
        }

        // Initialize
        init();
    </script>
</body>

</html>